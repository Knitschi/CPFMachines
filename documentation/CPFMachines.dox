/**
\defgroup CPFMachinesGroup CPFMachines

\brief Provides a script that sets up a jenkins-server, jenkins-slaves and a web-server on machines in a local network.

The CPF infrastructure includes a Jenkins server, build slaves and web-servers for hosting the generated html pages.
This package provides a python script for setting up these servers. The setup script requires a user provided configuration file
and ssh access to all involved machines in the network.

The jenkins server can be configured to contain build-jobs for CPF based repositories. For each of these projects, a web-server
is set up to host the html content that is generated by the CPF-projects build pipeline.

CPFMachines also provides a python script to deploy post-receive hooks to the cpf-project repositories.

<HR>

\section CPFMachinesUsageSection Usage

\subsection CPFMachinesRequirementsSubsection Requirements

- At least one Linux Machine.
- For Windows builds, an additional Windows machine is required.
- All machines must be in a local network, that also contains the machine that runs the setup script.
- Linux machines must be accessible via OpenSSH from the script-runner.
- Linux machines must have docker installed.
- Windows machines must be accessible via "Bitvise SSH Server" from the script-runner.
- Windows machines must have the `slave.jar` copied to "C:\jenkins"?
- On windows build-slaves all tools that are required to run the CPF pipeline must be manually installed.

\todo Setup infrastructure on fresh systems and complete the list.


\subsection CPFMachinesSetupSubsection Setting up the infrastructure

After setting up the host-machines and getting the CPFMachines package, 
you are ready to set up the servers that are involved in the CPF infrastructure.
If you want to use the infrastructure for multiple projects, it is recommended
that you create an extra CPF-project that holds the configuration files that
are needed when running the setup scripts. If you use the jenkins server for a
single CPF-project you can add the configuration files to the global files if 
that project. In both cases you will have to add the CPFMachines and most likely
the CPFJenkinsjob package to the CPF-project that holds the configuration files.


\subsubsection CPFMachinesConfigurationsSubsubsection Machine configuration

\todo Automatically add the content of the example config file here and manually add comments.


\subsubsection CPFMachinesRunningSubsubsection Running the script

When you added the configuration file to the project, you are ready to go.
Start the setup script by running

\code{.sh}
python -m Sources.CPFMachines.setup Sources/MyCPFMachinesConfig.json
\endcode

in the root directory of your project. This may take some time because some of
the tools required for the pipeline build need to be compiled while setting up
the docker container. If everything went well the script ends with the output

\code{.sh}
Successfully startet jenkins master, build slaves and the documentation server.
\endcode

If you used the example config file, you should now be able to access the Jenkins
web-interface under [http://MyMaster:8080](http://MyMaster:8080) and the projects
web-server under [http://MyMaster:80](http://MyMaster:80). However, the links to your
projects will only work after running their build-jobs.

\todo Change webserver file structure, that multiple project pages can be served (serachindex?)
and an index.html in the base directory provides links to the single projects.

\section CPFMachinesProblemsSection Problems

- Machine names in the config.json files should be given in lower case only, or problems with authenticating ssh server hosts can occur.
- I was not able to make name resolution for windows machines in the host network work inside the docker containers. The machine names for the windows build-slaves
therefore must be given as ip addresses to allow the jenkins-master to reach them. 

\warning All machines should be within a trusted network as machine to machine communication is currently vulnerable to man in the middle attacks due to
ignoring ssh host key checking.

\section CPFMachinesHookSetupSection Automatic build-Job execution

In day to day development it is practical when the build-job is run automatically whenever a developer
pushes commits that should be integrated into a main branch of the project. To enable that CPFJenkinsjob
provides a python module that adds hook scripts to the repositories of your CPF-projects.

\todo Add documentation for hook config and how to run it.


\section JobParameterSection Running the CPF Jenkins job

The jenkins job that is created by this package is a parameterized job. The parameters can be used to
execute multiple tasks on a CPF CI-project when the job is started via the Jenkins web-interface.


\subsection JobSubsection1 1. Integrating new commits

In this mode, the job verifies the commits made to an integration branch by building the pipeline in all
configurations, merge the commits to a main branch and add a new internal-version tag to mark
the commit as a successful build. The project web-page will be updated with the latest version of the 
generated documentation. This mode is the most common use case, which should be triggered automatically 
when pushing commits to an integration branch of the build repository or one of the package repositories.

To do an integration job following parameters must be set:

- <b>branchOrTag:</b> origin/\<name\>-int-\<MainBranch\>
- <b>task:</b> integration
- <b>package:</b>   If a package was changed, this must be set to the package name.
                    Note that this must be a package that has its versioning handled by
                    this build project.


all other can be left at their defaults.


\subsection JobSubsection2 2. Tagging a commit with a release version

In this mode the job will overwrite an existing internal version tag with a release version and rebuild
the tagged commit to create build artifacts with the new version. In this case you need to specify which 
part/digit of the version number should be incremented. The less significant digits are reset to zero. 
This will also update the projects web-page.

To create a release tag, the following parameters must be set:

- <b>branchOrTag:</b>  existing internal version-tag
- <b>task:</b>         one of incrementMajor, incrementMinor, incrementPatch

all other can be left at their defaults.


\subsection JobSubsection3 3. Rebuild an existing commit

Sometimes it is necessary to rebuild an already integrated commit in order to recreate build artifacts.
In this mode, the job will not touch the version tags are changed. This will also update the projects web-page.
When none of the jobs default parameters are changed, it executes this task for the master branch.

To rebuild an existing commit the following parameters must be set:

- <b>branchOrTag:</b>  \<version-tag\>

all other can be left at their defaults.


\subsection JobSubsection4 4. Testing or debugging the job itself

When working on the CMakeProjectFramework itself, it is sometimes useful to speed up the build-job by running it
with a reduced workload and without modifying the repository. Reducing the workload can be achieved by limiting
the build to a special configuration and/or a special target.

In this case the following parameters must be set:

- <b>branchOrTag:</b>       origin/\<someBranch\>  (this should be the branch you work on)
- <b>task:</b>              rebuild
- <b>package:</b>           The package you work on.
- <b>cpfConfiguration:</b>  The configuration you are interested in.
- <b>target:</b>            The target that is build.
  

\section CPFMachinesNotesSection Notes

- With the current implementation, parallel execution of the build-job is not possible.
This is because the version of a commit must stay the same while the job is running, because
the current version number is retrieved multiple times from the repository while the job is running.
Chaning the number in the meantime would lead to inconsistencies. In the longer run it would be
good to remove this limitation, which could be a showstopper for highly frequented projects with long
buildtimes. Another problem is that we do not get a build for each push, which makes it harder to pinpoint
failed builds to a specific push/developer.

- When using the CPF on Windows, one may be hitting the 260 character limit for filenames. On Windows 10, this
limit can be switched off. When building on older windows versions, the user can try to reduce the length of his
configuration names, package names or ci-project name. 


\section CPFMachinesTestsSection Tests

This is a list of non automated tests. This should only be a stopgap solution until
they are automated.


\subsection CPFMachinesTestsVerioningSection Tests for versioning mechanics
- Running a successful build for an already pushed commit without a version tag should add an internl version tag to that commit.
- Setting a release version tag should only work when the build is run on an internal version tag.
- It should not be possible to create a release version tag that already exists.
- When createin a release version, the old internal version tag should be deleted.
- Owned packages should be updated during the job run if new commits are available.
- The job should fail when release tagging a non owned package



*/



//##########################################################################################
/**

\section Rework Machines docs

This section contains information about the machines that are used to automatically build the pipeline
and provide the projects html pages.


## Machine Setup ##

This section describes which machines, virtual machines and docker images are used to provide the development infrastructure
for the CppCodeBase project.

Currently the setup includes the native Debian machine \c Feldrechengeraet. This native machine runs three docker containers and a virtual Windows 10 machine.

The pipeline requires a windows based build-slave for Jenkins which is currently implemented as a virtual machine.
This machine has been configured manually and then a backup was made.
The backup is stored on the DatenBunker machine in the \c /share/Knitschi/SystemBackups/CurrentBuildKnechts directory.
When the machine is started, a script will automatically start the jenkins-slave service.

The medium-term goal is to remove the need for stored virtual machines and replace them with docker containers or "blank"
virtual machines plus scripts that will do the machine setup. This is supposed to improve the "documentation" of the
state of the build-machines because all the scripts that define them are contained in the repository.

Setting up the involved docker containers on Linux only requires the execution of the \c setupDockerContainer.sh script that can be found in the
\c Infrastructure/DockerImages directory of the CppCodeBase.


### Starting The Linux Docker Containers ###

Currently the following machines are implemented as Linux based docker containers.

- \b Documentation-Server: Hosts the html pages that are generated by the build pipeline. Currently this is the Doxygen documentation and a report from the OpenCppCoverage tool.

- \b Jenkins-Master: The machine that runs the Jenkins master and which is accessed to observer the build-pipeline.

- \b Jenkins-Slave-Linux-0: The machine on which the actual builds of the Linux parts of the pipeline are done.

To set these machines up, one needs a debian machine that has docker and git installed. Then the CppCodeBase repository needs to be checked out in order to get the scripts.
One also needs to create a directory that will act as the home directory of the jenkins-master and is shared between the host and the container.
Currently this directory is hardcoded to \c /home/knitschi/jenkinsmastercontainer which may need to be transformed to an script argument later.

The \c Infrastructure/DockerImages folder ccbContains the \c setupDockerContainer.sh script which does all the work.
Running it will require an working ssh connection to \c Datenbunker machine in order to setup the connection from the
\c jenkins-master to the \c Datenbunker. 

\bug Network issues after running setupDockerContainer.sh
Setting up the docker container changes the network settings of the host. This may cause the the
\c setupDockerContainer.sh script to fail when run multiple times in a row because connection to the
internet can not be made. Restarting the machine on which the script is run will solve the problem.


### The Windows Slave ###

There is a virtual machine that is used as a build-slave for the parts of the pipeline that must be build on Windows.
Whenever the container for the \c jenkins-master machine is re-built, the connection information on the windows slave
must be updated in the script that can be found on the windows-slave under

\c C:/jenkins/startSlave.bat

To update the information one must to login to jenkins from within the windows-slave and go to the page

<a href="http://feldrechengeraet:8080/computer/jenkins-slave-windows-0/">http://feldrechengeraet:8080/computer/jenkins-slave-windows-0</a>

and copy the displayed secret into the batch file. The batch file is run after each start of the windows-slave
to reestablish the connection to the jenkins-master server.


## The Jenkins Build Server ##

* The server is setup in the \c jenkins-master container. Manual changes to the server via the web-interface
are lost when the \c setupDockerContainer.sh is re-run. This includes updates to plugins and jenkins itself.
Therefore non-experimental changes must be implemented by changing the files in the \c Infrastructure/DockerImages directory.
* The web-page of the jenkins-server is <a href="https://jenkins.io/"><b>here</b></a>.
* There is a post-commit hook that starts the pipeline.
* The pipeline script builds the \c pipeline target on Linux and Windows in two configurations each.
* The pipeline script collects html output of the pipeline and copies it to a web-server.


## Git ##

The Git repository is hosted on the DatenBunker machine in the directory \c /share/GitRepositories/CppCodeBase. The repository
has a post-commit-hook that triggers the <a href="http://feldrechengeraet:8080/job/CppCodeBase_Build_PipeLine/">CppCodeBase_Build_Pipeline</a> job on the Jenkins server.


\todo Buy a more powerfull build-machine to reduce the overall pipeline time.
*/
